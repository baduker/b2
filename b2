#!/bin/bash

# b2 [BranchBuster] - A utility script that removes gone AND merged branches.

set -euo pipefail

readonly VERSION="0.3.1"

# automatically detect main or master
readonly MAIN_BRANCH=$(
  git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null \
    | sed 's@^refs/remotes/origin/@@' || echo "main"
  )

: <<'HELP'
Usage: b2 [options]
HELP

# show usage message
show_usage() {
  echo "Usage: b2 [options]"
  echo "Options:"
  echo "  --help        Show this help message"
  echo "  --force       Force delete branches without asking for confirmation"
  echo "  --version     Show script version"
}

show_help() {
  echo -e "\nA utility script that removes gone and merged branches from the local repository."
  show_usage
}

find_prunable_branches() {
  # 1. Update remote list
  git fetch -p > /dev/null 2>&1

  # 2. Get "Gone" branches (Using your working 0.2.3 logic)
  local gone_branches
  gone_branches=$(git branch -vv | awk '/: gone]/{if ($1 != "*") print $1}')

  # 3. Get "Merged" branches (Excluding main/master/dev)
  local merged_branches
  merged_branches=$(git branch --merged "$MAIN_BRANCH" | \
    sed 's/^[ *]*//' | \
    grep -vE "^($MAIN_BRANCH|master|main|dev|development)$")

  # 4. Combine and cleanup
  echo -e "$gone_branches\n$merged_branches" | sort | uniq | grep -v "^$"
}

delete_branches() {
  set +e
  local branch
  local branches=("$@")
  local current_branch
  current_branch=$(git branch --show-current)

  for branch in "${branches[@]}"; do
    if [[ "$branch" == "$current_branch" ]]; then
        echo "Skipping currently checked out branch: $branch"
        continue
    fi
    # -D forces deletion even if git thinks it's not merged (useful for the [gone] ones)
    git branch -D "$branch" || echo "Failed to delete branch: $branch"
  done
  set -e
}

ask_for_user_input() {
  local answer
  local branches_to_kill=("$@")
  
  echo "The following branches are safe to delete (Merged or Gone):"
  for i in "${!branches_to_kill[@]}"; do
    echo "$((i + 1)). ${branches_to_kill[$i]}"
  done

  local main_prompt="Enter 'y' to delete all, 'n' to skip, or select by number: "
  while true; do
    read -r -p "$main_prompt" answer
    case "$answer" in
      [Yy])
        delete_branches "${branches_to_kill[@]}"
        break
        ;;
      [Nn])
        echo "No branches deleted."
        break
        ;;
      *)
        if [[ "$answer" =~ ^[0-9]+( [0-9]+)*$ ]]; then
          local number
          local selected_branches=()
          for number in $answer; do
            if ((number > 0 && number <= ${#branches_to_kill[@]})); then
              selected_branches+=("${branches_to_kill[$((number - 1))]}")
            else
              echo "Invalid branch number: $number"
            fi
          done
          if [ "${#selected_branches[@]}" -gt 0 ]; then
             delete_branches "${selected_branches[@]}"
          fi
          break
        else
          echo "Invalid input."
        fi
        ;;
    esac
  done
}

show_version() {
  echo -e "\nb2 [BranchBuster] v${VERSION}"
}

main() {
  local force_delete=false

  while [ $# -gt 0 ]; do
    case "$1" in
      --help) show_help; exit 0 ;;
      --version) show_version; exit 0 ;;
      --force) force_delete=true ;;
      *) echo "Unknown option: $1"; show_usage; exit 1 ;;
    esac
    shift
  done

  echo "Scanning for branches merged into '$MAIN_BRANCH' or with deleted remotes..."
  
  local -a branches_to_kill=()
  while IFS= read -r line; do
    branches_to_kill+=("$line")
  done < <(find_prunable_branches)

  if [ "${#branches_to_kill[@]}" -gt 0 ]; then
    if [ "$force_delete" = true ]; then
      printf "\nForce deleting:\n"
      printf '%s\n' "${branches_to_kill[@]}"
      delete_branches "${branches_to_kill[@]}"
    else
      ask_for_user_input "${branches_to_kill[@]}"
    fi
  else
    echo -e "\nClean! No merged or gone branches found."
  fi
  show_version
}

main "$@"
